'''
Lecture 4: Sorting in Linear Time
    Overview
        Counting Sort
        Radix Sort
        Bucket Sort
    Objective
        Understand that comparison is not the only method to sort lists
        Learn about sorting algorithms that run in linear time
    Introduction
        Now know several algorithms that can sort in O(nlogn) time
            Merge sort and heap sort achieve upper bound in worst case
            Quick sort achieves this on average
        Property: the sorted order they determine is only based on comparison between the input elements --> comparison sorts
    Lower bounds for sorting
        Comparison sort
            Use only comparison between input sequence to gain order information
            Given a(i) and a(j) perform tests to see the comparison between the two numbers
        Now value inspection, no gaining of order information in any other way
        Assumption: all input elements are distinct
            Comparison a(i) = a(j) is useless
            All other comparisons are equivalent since they yield identical information about relative order
            Therefore all comparisons have form a(i) <= a(j)
    Lower bound for worst case
        Worst case number of comparisons:
            Longest path from root to any reachable leave
            Height of decision tree is lower bound
    Counting sort
        Assumes n input elements (all integers) in range 0 to k
        Basic idea: Determine for each input element x, number of elements less than x
        Information can be used to place element x directly into its position in output array
        E.g. if there are 17 elements less than x, it belongs in output position 18
    Counting sort - algorithm
        Input array A[1..n]
        B[1..n] holds stored output
        C[0..k] provides temporary working storage
    Radix Sort
        Sort numbers in a column digit by digit
        Starting with the least significant bit
        In computer, used to sort records of information keyed by multiple fields
    Bucket Sort
        Assumption about input
            Input is drawn from uniform distribution
            Input is generated by random process that distributes elements uniformly and independently over interval [0,1)
            In counting sort: input consists of integers in a small range
        Idea: divide interval [0,1) into n equal sized subintervals or buckets
        Distribute n input numbers into buckets
        Since input uniformly and independently distributed over [0,1) =:> expect not too many numbers fall into one bucket
        Output: simply sort numbers in each bucket and go through buckets in order
    Bucket sort - analysis
        All lines except line 5 take O(n) time in worst case
        Analysis of cost insertion sort reveals that expected time for Bucket Sort is: O(n)
        Runs in linear expected time

'''